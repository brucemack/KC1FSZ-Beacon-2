/*
 * Driver.cpp
 *
 *  Created on: Feb 22, 2020
 *      Author: Bruce MacKinnon KC1FSZ
 */

#include <stdio.h>
#include "Driver.h"

extern "C" {
#include "main.h"
#include "ssd1306.h"

#if defined(STM32F1)
#include "stm32f1xx_hal.h"
#endif
}

#include "I2CInterface.h"
#include "si5351.h"
#include "VFOInterface.h"
#include "SystemEnv.h"
#include "RttyEncoder.h"

// ----------------------------------------------------------------------------
// Get the system environment
class SystemEnv1 : public kc1fsz::SystemEnv {
public:

	uint32_t getTimeMs() {
		return HAL_GetTick();
	}
};
static SystemEnv1 sysenv1;

// ----------------------------------------------------------------------------
// Wrap the I2C interface so that the Si5351 library can talk to it
extern I2C_HandleTypeDef hi2c1;
static kc1fsz::I2CInterface ic21(&hi2c1);

// ----------------------------------------------------------------------------
// Wrap the SI5351 library in the VFOInterface
class VFO1 : public kc1fsz::VFOInterface {
public:

	void setOutputEnabled(bool e) {
		if (e != _enabled) {
			if (!e)
				si5351aOutputOff(1);
			else
				si5351aOutputOff(0);
			_enabled = e;
		}
	}

	void setFrequency(unsigned int freqHz) {
		// NOTE: No reset here since we should not be moving far from the base
		si5351aSetFrequency(freqHz, false);
	}

private:

	bool _enabled = false;
};
static VFO1 vfo1;

// ----------------------------------------------------------------------------
// Wrap the LED in the status indicator interface
class Ind1 : public kc1fsz::StatusIndicator {
public:
	void setLight(bool s) {
		if (s) {
			HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
		} else {
			HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
		}
	}
	/**
	 * Render a short message on the top right of the display
	 */
	void setMessage(const char* msg) {
		char buf[9];
		int i;
		for (i = 0; i < 8 && msg[i] != 0; i++)
			buf[i] = msg[i];
		for (;i < 8; i++)
			buf[i] = ' ';
		buf[i] = 0;
		ssd1306_SetCursor(64, 0);
		ssd1306_WriteString(buf, Font_7x10, White);
		ssd1306_UpdateScreen();
	}
};
static Ind1 ind1;

// ----------------------------------------------------------------------------
// Get the RTTY encoder integrated with the hardware
static kc1fsz::RttyEncoder encoder(&sysenv1, &vfo1, &ind1);

static const unsigned int freq = 7040000;

// Bulletin message
static const char* msg =
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"DE DE DE KC1FSZ KC1FSZ KC1FSZ\r\n"
"DE DE DE KC1FSZ KC1FSZ KC1FSZ\r\n"
"\r\n"
"QST QST QST\r\n"
"BE ADVISED THAT THE SCI TECH AMATEUR RADIO CLUB (STARS) WILL BE HOLDING\r\n"
"ITS MONTHLY MEETING ON 10 MAR 2020 AT 1900 EST (11 MAR 0000Z)\r\n"
"AT NEW ENGLAND SCI-TECH. ALL ARE WELCOME!\r\n"
"ADDRESS IS 16 TECH CIRCLE, NATICK, MA.\r\n"
"GRID SQUARE FN42HH.\r\n"
"\r\n"
"UPDATES WILL BE TRANSMITTED AS THEY ARE AVAILABLE.\r\n"
"\r\n"
"DE DE DE KC1FSZ FC1FSZ KC1FSZ\r\n"
"THIS TRANSMISSION WAS GENERATED BY AN RTTY BEACON WITH 100MW PEP OUTPUT POWER\r\n"
"\r\n"
"SK\r\n";

static void Driver_displayFreq(unsigned int freq) {
	char buf[32];
	int x = 50;
	// Print whole KHz
	sprintf(buf,"%5d",freq / 1000);
	ssd1306_SetCursor(x, 12);
	ssd1306_WriteString(buf, Font_11x18, White);
	// Print 100Hz increments
	sprintf(buf,".%d",(freq % 1000) / 100);
	ssd1306_SetCursor(x + 55, 12);
	ssd1306_WriteString(buf, Font_11x18, White);
	ssd1306_UpdateScreen();
}

void Driver_init() {

	si5351aInit(&ic21);
	// Set frequency and force a reset
	si5351aSetFrequency(freq, true);

	ssd1306_Init();
	ssd1306_Fill(Black);
	// Logo
	ssd1306_SetCursor(0, 0);
	ssd1306_WriteString((char*)"KC1FSZ", Font_7x10, White);
	for (int x = 0; x < 128; x++)
		ssd1306_DrawPixel(x, 10, White);
	ssd1306_UpdateScreen();

	// Toggle (diagnostics)
	for (int i = 0; i < 4; i++) {
		ind1.setLight(true);
		HAL_Delay(250);
		ind1.setLight(false);
		HAL_Delay(250);
	}

	Driver_displayFreq(freq);

	// Set the transmit frequency
	encoder.setFreq(freq);
	// Setup the message to be broadcast on the
	encoder.queueMessage(msg);
	encoder.start();
}

long lastStrobe = 0;

void Driver_loop() {
	encoder.poll();
}
